// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel MarchingCubes

#include "/Lib/MarchingCubeLib.compute"

//input
RWStructuredBuffer<float4> vertexPerlin;

//variables
const int pointsPerAxis;
const float cutoff;
const float3 startingValue;
const float1 groundLevel;
const float1 layerThickness;

Texture2D<float4> groundTex;
const float1 height;
const float1 frequency;



int generateConfiguration(float4 corners[8], int idx, int idz)
{
    int configurationNumber = 0;
    
    uint w, h;
    groundTex.GetDimensions(w, h);
    
    
    //loops through all corners and based on which corner we are on we increase the configuration number
    for (int i = 0; i < 8; i++)
    {
        //formula for a ground level, the higher the y the less air there is, till a ground level has been reached, then only air.
        //if (corners[i].w > cutoff + ((corners[i].y + startingValue.y) / groundLevel * 0.25f) || (corners[i].w + ((corners[i].y + startingValue.y - groundLevel) / layerThickness)) > cutoff)
        //{
        //    configurationNumber += pow(2, (i));
        //}        
        float2 vec;
        vec.x = corners[i].x + startingValue.x;
        vec.y = corners[i].z + startingValue.z;
        float test = groundTex[vec / frequency % w];
        test *= height;
        
        if (corners[i].w > cutoff + ((corners[i].y + startingValue.y) / (groundLevel * 0.25f + test)) || (corners[i].w + ((corners[i].y + startingValue.y - groundLevel - test) / layerThickness)) > cutoff)
        {
            configurationNumber += pow(2, (i));
        }
    }
    
    return configurationNumber;
}

int getIndex(int x, int y, int z)
{
    //since xyz is going from 0 to number, it can will return correct number
    //example: if points per axis is 10, it means that xyz max is 9. So the final number will be 999
    //this is correct because 10x10x10 is 1000, and 0 - 999 is 1000.
    int index = z * pointsPerAxis * pointsPerAxis + y * pointsPerAxis + x;

    return index;
}



struct TriangleStruct
{
    float3 VertexC;
    float3 VertexB;
    float3 VertexA;
};


//output
AppendStructuredBuffer<TriangleStruct> triangles;


float3 interpolate(float4 vertexA, float4 vertexB)
{
    
    float alpha;
    //This vector is used to save the interpolated point between the two given vectors.
    float3 interpolatedVector;
        
    if (abs(cutoff - vertexA.w) < 0.00001f)
        return vertexA.xyz;
    if (abs(cutoff - vertexB.w) < 0.00001f)
        return vertexB.xyz;
    if (abs(vertexA.w - vertexB.w) < 0.00001f)
        return vertexA.xyz;

    
    alpha = (cutoff - vertexA.w) / (vertexB.w - vertexA.w);
        
    //Component based linear interpolation
    interpolatedVector.x = vertexA.x + alpha * (vertexB.x - vertexA.x);
    interpolatedVector.y = vertexA.y + alpha * (vertexB.y - vertexA.y);
    interpolatedVector.z = vertexA.z + alpha * (vertexB.z - vertexA.z);

    //return interpolatedVector;

    
    
    return (vertexA.xyz + vertexB.xyz) / 2;
    
    //float t = (0.5f - vertexA.w) / (vertexB.w - vertexA.w);
    //return vertexA.xyz + t * (vertexB.xyz - vertexA.xyz);
}


void createTriangles(float4 corners[8], const int configurationNumber)
{

    for (int i = 0; triTable[configurationNumber][i] !=  -1; i += 3)
    {

        float3 newVertexA = interpolate(corners[edgeIndex[triTable[configurationNumber][i]][0]], corners[edgeIndex[triTable[configurationNumber][i]][1]]);
        float3 newVertexB = interpolate(corners[edgeIndex[triTable[configurationNumber][i + 1]][0]], corners[edgeIndex[triTable[configurationNumber][i + 1]][1]]);
        float3 newVertexC = interpolate(corners[edgeIndex[triTable[configurationNumber][i + 2]][0]] , corners[edgeIndex[triTable[configurationNumber][i + 2]][1]]);
        
        
        TriangleStruct newTriangle1;
        newTriangle1.VertexA = newVertexA;
        newTriangle1.VertexB = newVertexB;
        newTriangle1.VertexC = newVertexC;

            
        triangles.Append(newTriangle1);

    }

}


[numthreads(8,8,8)]
void MarchingCubes(uint3 id : SV_DispatchThreadID)
{
    //check if we are not over the chunk size (its possible since we cannot dispatch 1,5f compute shader)
    if (id.x >= pointsPerAxis - 1 || id.y >= pointsPerAxis - 1 || id.z >= pointsPerAxis - 1)
    {
        return;
    }
    
    
    //get corners index
    float4 corners[8] =
    {
        vertexPerlin[getIndex(id.x, id.y + 1, id.z)],
        vertexPerlin[getIndex(id.x + 1, id.y + 1, id.z)],
        vertexPerlin[getIndex(id.x + 1, id.y, id.z)],
        vertexPerlin[getIndex(id.x, id.y, id.z)],
        vertexPerlin[getIndex(id.x, id.y + 1, id.z + 1)],
        vertexPerlin[getIndex(id.x + 1, id.y + 1, id.z + 1)],
        vertexPerlin[getIndex(id.x + 1, id.y, id.z + 1)],
        vertexPerlin[getIndex(id.x, id.y, id.z + 1)]
    };
    
    //generate configuration
    int configurationNumber = generateConfiguration(corners, id.x, id.z);
    

    
    //create triangle
    createTriangles(corners, configurationNumber);
    
}

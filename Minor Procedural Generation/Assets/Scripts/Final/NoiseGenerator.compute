// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "/Lib/NoiseLib.compute"

const float1 chunkSize;
const float1 row;
const float1 height;
const float1 column;
const float1 size;
const float1 noiseScale;
const float1 repeat;
const int pointsPerAxis;
const float1 groundHeight;
const float1 mountainHeight;
const float1 persistence;
const float1 lacunarity;
const int octaves = 1;


//height noise map


    
    



float3 startingValue;


RWStructuredBuffer<float4> vertexPerlin;

static int numThreads = 8;



float interpolate(float value)
{
    return value * value * value * (value * (value * 6 - 15) + 10);
}


static float gradplane(int hash, float x, float y)
{
    switch (hash & 0x3)
    {
        case 0x0:
            return x + y;
        case 0x1:
            return -x + y;
        case 0x2:
            return x - y;
        case 0x3:
            return -x - y;
        default:
            return 0; // never happens
    }
}

float heightmapNoise(float x, float y)
{
    //points in the perlin space
    float pointA = x - floor(x);
    float pointB = y - floor(y);

    // Calculate the "unit cube" that the point asked will be located in
    int xi = (int) x & 255;
    int yi = (int) y & 255;
    
    //get a semi-random number from a table for 255 included numbers
    int testA = p[p[xi] + yi];
    int testB = p[p[xi + 1] + yi];
    int testC = p[p[xi] + yi + 1];
    int testD = p[p[xi + 1] + yi + 1];
    
    //based on those random numbers generate a direction, in this case from 4 different directions
    float testAh = gradplane(testA, pointA, pointB);
    float testBh = gradplane(testB, pointA - 1, pointB);
    float testCh = gradplane(testC, pointA, pointB - 1);
    float testDh = gradplane(testD, pointA - 1, pointB - 1);
    
    
    //Combine the directions together, 2 at the time, first on the X axis
    double resultA = lerp(testAh, testBh, interpolate(pointA));
    double resultB = lerp(testCh, testDh, interpolate(pointA));

    //then combine those 2 values together on the y axis
    float endResult = (float) lerp(resultA, resultB, interpolate(pointB));
    endResult = (endResult + 1) / 2;
    return endResult;
}


float selfmadeperlin(float x, float y, float z)
{

    int xi = (int) x & 255; // Calculate the "unit cube" that the point asked will be located in
    int yi = (int) y & 255; // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that
    int zi = (int) z & 255; // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.
    
    float pointX = x - floor(x);
    float pointY = y - floor(y);
    float pointZ = z - floor(z);

    
    
    float interX = interpolate(pointX);
    float interY = interpolate(pointY);
    float interZ = interpolate(pointZ);

    int cornerA = p[p[p[xi] + yi] + zi];
    int cornerB = p[p[p[xi] + yi + 1] + zi];
    int cornerC = p[p[p[xi] + yi] + zi + 1];
    int cornerD = p[p[p[xi] + yi + 1] + zi + 1];
    
    int cornerE = p[p[p[xi + 1] + yi] + zi];
    int cornerF = p[p[p[xi + 1] + yi + 1] + zi];
    int cornerG = p[p[p[xi + 1] + yi] + zi + 1];
    int cornerH = p[p[p[xi + 1] + yi + 1] + zi + 1];

    float cornerAdir = grad(cornerA, pointX, pointY, pointZ);
    float cornerBdir = grad(cornerB, pointX, pointY - 1, pointZ);
    float cornerCdir = grad(cornerC, pointX, pointY, pointZ - 1);
    float cornerDdir = grad(cornerD, pointX, pointY - 1, pointZ - 1);
    
    float cornerEdir = grad(cornerE, pointX - 1, pointY, pointZ);
    float cornerFdir = grad(cornerF, pointX - 1, pointY - 1, pointZ);
    float cornerGdir = grad(cornerG, pointX - 1, pointY, pointZ - 1);
    float cornerHdir = grad(cornerH, pointX - 1, pointY - 1, pointZ - 1);
    
    float resultA = lerp(cornerAdir, cornerEdir, interX);
    float resultB = lerp(cornerBdir, cornerFdir, interX);
    float resultC = lerp(cornerCdir, cornerGdir, interX);
    float resultD = lerp(cornerDdir, cornerHdir, interX);
    
    float resultE = lerp(resultA, resultB, interY);
    float resultF = lerp(resultC, resultD, interY);
    
    float resultG = lerp(resultE, resultF, interZ);
    
    
    //most values are between 0.25f and 0.75, this formula tries to normalize it to 0 to 1
    float result = (((resultG + 1) / 2) - 0.25f) * 2;
    return result;

    //return y1;
}


int getIndex(int x, int y, int z)
{
    //since xyz is going from 0 to number, it can will return correct number
    //example: if points per axis is 10, it means that xyz max is 9. So the final number will be 999
    //this is correct because 10x10x10 is 1000, and 0 - 999 is 1000.
    int index = z * pointsPerAxis * pointsPerAxis + y * pointsPerAxis + x;

    return index;
}

    
    //1 = air!! -------------------------------------------------------

float worms(float x, float y, float z)
{
    float currentHeight = y;
    
    float baseX = x;
    float baseY = y;
    float baseZ = z;
    
    
    float caveX = x / 150;
    float caveY = y / 150;
    float caveZ = z / 150;
    

    x /= noiseScale;
    y /= noiseScale;
    z /= noiseScale;
    
    
    const float gh = 350;
 
    const float mh = 400;
    const float ch = 300;
    //the higher the number the more flat area is between the mountains
    const float exp = 4;
    const float caveDelta = 10;
    const float mountainSmoothness = 5;
    
    
    float noise = 0;
    float weight = 1;

    float testScale = 150;
        
    float maxValue = 0;
    float topheight = 350;
    float caveResult = 1;
    
    //==============================================================================================================================
    //=================================                                       HEIGHTMAP                                                     ============================
    //==============================================================================================================================
    
    for (int j = 0; j < octaves; j++)
    {
        float test2 = heightmapNoise(baseX / testScale, baseZ / testScale);
        noise += (test2 * weight);
        //0.9 because 1 is very unlikely so this is a more accurate representation
        maxValue += (0.9f * weight);
        testScale *= lacunarity;
        weight *= persistence;
    }
        
    //normalize value
    noise = noise / maxValue;
    
    //==================================                   Setting values                ==========================================================
    topheight += (pow((noise * 10), exp)) * (((mh) / 100) / (pow(10, (exp - 2))));
    float caveheight2 = ch + noise * mh;
    

    //==============================================================================================================================
    //====================================                                       CAVES                                                     ==============================
    //==============================================================================================================================
    
    
    for (int m = 1; m < 5; m++)
    {
        float factor = pow(2, m);
        caveResult -= selfmadeperlin(caveX * factor, caveY * factor, caveZ * factor) / factor;
    }
    
    float caveheight = 0.65f;
    if (caveResult > caveheight)
    {
        caveResult = 0;
    }
    else
    {
        caveResult = 1 - (caveResult / caveheight);
    }
        
    float endResult = caveResult;
    
    if (currentHeight > topheight - caveDelta)
    {
        //3 means the amount of caves that go to surface, the higher the number, the more entrances
        endResult -= (1 - ((topheight - currentHeight) / caveDelta)) / 4;
    }
    

    //==============================================================================================================================
    //==================================                                       TERRAIN                                                     ==============================
    //==============================================================================================================================
    
    


    if (currentHeight > topheight)
    {
        endResult += (1 - (topheight + mountainSmoothness - currentHeight) / mountainSmoothness);
        float value = selfmadeperlin(baseX / 5.5f, baseY / 10.5f, baseZ / 5.5f);
        float value2 = selfmadeperlin(baseX / 9.5f, baseY / 37.5f, baseZ / 9.5f);
        endResult -= (value / 2 + value2) / 3;
    }

    
    return endResult;
}





[numthreads(numThreads, numThreads, numThreads)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //if id is outside boundary return, this can happen due to that pointsperaxis/numthreads is not an int
    if (id.x >= pointsPerAxis || id.y >= pointsPerAxis  || id.z >= pointsPerAxis )
    {
        return;
    }

    //generate a value based on position and add it to the buffer, together with the postion
    float3 newPos = startingValue;

    

    newPos.x = (startingValue.x + (id.x * size ));
    newPos.y = (startingValue.y + (id.y * size ));
    newPos.z = (startingValue.z + (id.z * size ));

    vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size , id.y * size , id.z * size , worms(newPos.x, newPos.y, newPos.z)));
   

}


// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "/Lib/NoiseLib.compute"

const float1 chunkSize;
const float1 row;
const float1 height;
const float1 column;
const float1 size;
const float1 noiseScale;
const float1 repeat;
const int pointsPerAxis;
const float1 groundHeight;
const float1 mountainHeight;
const float1 persistence;
const float1 lacunarity;
const int octaves = 1;

const float1 heightMapScale = 150;
    
//cave variables
const float1 caveCutoff;
const float1 caveScale = 150;
const float1 caveMin = 0;
const float1 caveMax = 250;
const float1 caveDelta = 75;
const float1 caveStrength = 0.1f;

    //the higher the number the more flat area is between the mountains
const float1 exp = 4;

float1 varMountainHeight;
float1 varMountainFrequention;
float1 varMountainExp;
float1 varGroundHeight;

//height noise map


    
    



float3 startingValue;


RWStructuredBuffer<float4> vertexPerlin;
//RWStructuredBuffer<float3> treePositions;
AppendStructuredBuffer<float3> treePositions;
AppendStructuredBuffer<float3> flowerPositions;

static int numThreads = 8;



float interpolate(float value)
{
    return value * value * value * (value * (value * 6 - 15) + 10);
}


static float gradplane(int hash, float x, float y)
{
    switch (hash & 0x3)
    {
        case 0x0:
            return x + y;
        case 0x1:
            return -x + y;
        case 0x2:
            return x - y;
        case 0x3:
            return -x - y;
        default:
            return 0; // never happens
    }
}

float heightmapNoise(float x, float y)
{
    //points in the perlin space
    float pointA = x - floor(x);
    float pointB = y - floor(y);

    // Calculate the "unit cube" that the point asked will be located in
    int xi = (int) x & 255;
    int yi = (int) y & 255;
    
    //get a semi-random number from a table for 255 included numbers
    int testA = p[p[xi] + yi];
    int testB = p[p[xi + 1] + yi];
    int testC = p[p[xi] + yi + 1];
    int testD = p[p[xi + 1] + yi + 1];
    
    //based on those random numbers generate a direction, in this case from 4 different directions
    float testAh = gradplane(testA, pointA, pointB);
    float testBh = gradplane(testB, pointA - 1, pointB);
    float testCh = gradplane(testC, pointA, pointB - 1);
    float testDh = gradplane(testD, pointA - 1, pointB - 1);
    
    
    //Combine the directions together, 2 at the time, first on the X axis
    double resultA = lerp(testAh, testBh, interpolate(pointA));
    double resultB = lerp(testCh, testDh, interpolate(pointA));

    //then combine those 2 values together on the y axis
    float endResult = (float) lerp(resultA, resultB, interpolate(pointB));
    endResult = (endResult + 1) / 2;
    return endResult;
}


float selfmadeperlin(float x, float y, float z)
{

    int xi = (int) x & 255; // Calculate the "unit cube" that the point asked will be located in
    int yi = (int) y & 255; // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that
    int zi = (int) z & 255; // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.
    
    float pointX = x - floor(x);
    float pointY = y - floor(y);
    float pointZ = z - floor(z);

    
    
    float interX = interpolate(pointX);
    float interY = interpolate(pointY);
    float interZ = interpolate(pointZ);

    int cornerA = p[p[p[xi] + yi] + zi];
    int cornerB = p[p[p[xi] + yi + 1] + zi];
    int cornerC = p[p[p[xi] + yi] + zi + 1];
    int cornerD = p[p[p[xi] + yi + 1] + zi + 1];
    
    int cornerE = p[p[p[xi + 1] + yi] + zi];
    int cornerF = p[p[p[xi + 1] + yi + 1] + zi];
    int cornerG = p[p[p[xi + 1] + yi] + zi + 1];
    int cornerH = p[p[p[xi + 1] + yi + 1] + zi + 1];

    float cornerAdir = grad(cornerA, pointX, pointY, pointZ);
    float cornerBdir = grad(cornerB, pointX, pointY - 1, pointZ);
    float cornerCdir = grad(cornerC, pointX, pointY, pointZ - 1);
    float cornerDdir = grad(cornerD, pointX, pointY - 1, pointZ - 1);
    
    float cornerEdir = grad(cornerE, pointX - 1, pointY, pointZ);
    float cornerFdir = grad(cornerF, pointX - 1, pointY - 1, pointZ);
    float cornerGdir = grad(cornerG, pointX - 1, pointY, pointZ - 1);
    float cornerHdir = grad(cornerH, pointX - 1, pointY - 1, pointZ - 1);
    
    float resultA = lerp(cornerAdir, cornerEdir, interX);
    float resultB = lerp(cornerBdir, cornerFdir, interX);
    float resultC = lerp(cornerCdir, cornerGdir, interX);
    float resultD = lerp(cornerDdir, cornerHdir, interX);
    
    float resultE = lerp(resultA, resultB, interY);
    float resultF = lerp(resultC, resultD, interY);
    
    float resultG = lerp(resultE, resultF, interZ);
    
    
    //most values are between 0.25f and 0.75, this formula tries to normalize it to 0 to 1
    float result = (((resultG + 1) / 2) - 0.25f) * 2;
    return result;

    //return y1;
}


int getIndex(int x, int y, int z)
{
    //since xyz is going from 0 to number, it can will return correct number
    //example: if points per axis is 10, it means that xyz max is 9. So the final number will be 999
    //this is correct because 10x10x10 is 1000, and 0 - 999 is 1000.
    int index = z * pointsPerAxis * pointsPerAxis + y * pointsPerAxis + x;

    return index;
}

    
    //1 = air!! -------------------------------------------------------

float worms(float x, float y, float z)
{
    float currentHeight = y;
    
    float baseX = x;
    float baseY = y;
    float baseZ = z;
    
    
    float caveX = x / caveScale;
    float caveY = y / caveScale;
    float caveZ = z / caveScale;
    

    x /= noiseScale;
    y /= noiseScale;
    z /= noiseScale;
    

    
    //==============================================================================================================================
    //=================================                                       BIOMES                                                     ============================
    //==============================================================================================================================
    
    float mountainHeightNoiseOffset = selfmadeperlin(baseX / 800.5f, baseY / 800.5f, baseZ / 800.5f);
    float mountainExpNoiseOffset = selfmadeperlin(baseX / 700.5f, baseY / 700.5f, baseZ / 700.5f);
    float mountainFrequentionNoiseOffset = selfmadeperlin(baseX / 900.5f, baseY / 900.5f, baseZ / 900.5f);
    float groundLevelNoiseOffset = selfmadeperlin(baseX / 1000.5f, baseY / 1000.5f, baseZ / 1000.5f);
    float mountainHeightNoisePersistence = selfmadeperlin(baseX / 100.5f, baseY / 100.5f, baseZ / 100.5f);
    float hillNoise = selfmadeperlin(baseX / 250.5f, baseY / 250.5f, baseZ / 250.5f);
    


    varMountainHeight -= mountainHeightNoiseOffset * 100;
    if (varMountainHeight < 0)
    {
        varMountainHeight = 0;
    }
    varMountainExp += mountainExpNoiseOffset * 0.75f;
    varMountainFrequention -= mountainFrequentionNoiseOffset * 25;
    
    if (groundLevelNoiseOffset > 0.75f)
    {
        //groundLevelNoiseOffset += 0.5f;
    }
    //groundLevelNoiseOffset -= 0.25f;
    varGroundHeight += groundLevelNoiseOffset * 100;
    
    float topheight = varGroundHeight;
    float caveResult = 1;
    
    //==============================================================================================================================
    //=================================                                       HEIGHTMAP                                                     ============================
    //==============================================================================================================================
    
    float variableScale = heightMapScale;
    float maxValue = 0;
    float noise = 0;
    float weight = 1;
    
    for (int j = 0; j < octaves; j++)
    {
        float test2 = heightmapNoise(baseX / variableScale, baseZ / variableScale);
        noise += (test2 * weight);
        //0.9 because 1 is very unlikely so this is a more accurate representation
        maxValue += (0.9f * weight);
        variableScale *= lacunarity;
        weight *= persistence;
    }
        
    //normalize value
    noise = noise / maxValue;
    
    
    float subMountainsNoise = 0;
    float subMaxValue = 0;
    weight = 1;
    variableScale = varMountainFrequention / 1.5f;
    
    for (int j = 0; j < octaves; j++)
    {
        float test2 = heightmapNoise(baseX / variableScale, baseZ / variableScale);
        subMountainsNoise += (test2 * weight);
        //0.9 because 1 is very unlikely so this is a more accurate representation
        subMaxValue += (0.9f * weight);
        variableScale *= lacunarity;
        weight *= persistence;
    }
    subMountainsNoise = subMountainsNoise / subMaxValue;
    
    //==================================                   Setting values                ==========================================================
    
    
    float tempNoise = 0;
    float max = 0.65f;
    float min = 0.35f;
    
    if (noise < max && noise > min)
    {
        float absMin = min - min;
        float absMax = max - min;
        float value = (noise - min) / absMax;
        if (value <= 1)
        {
            value *= 2;
            value -= 1;
            value = abs(value) - 1;
            value = abs(value);
            tempNoise = value;
        }
    }

    clamp(tempNoise, 0, 1);
    
    //noise = tempNoise + subMountainsNoise;
    noise = subMountainsNoise;
    
    //makes exponential mountains possible, to disable just set exp to 1.
    float mountainPersistence = 0;
    float mPerDelta = 0.1f;
    float mCutoff = 0.5f;
    /*if (mountainExpNoiseOffset > mCutoff - mPerDelta)
    {
        mountainPersistence = (mountainExpNoiseOffset - (mCutoff - mPerDelta)) / ((mCutoff + mPerDelta) - (mCutoff - mPerDelta));
    }
    else
    {
        mountainPersistence = 0;
    }*/
    mountainExpNoiseOffset = (mountainExpNoiseOffset - (mCutoff - mPerDelta)) / ((mCutoff + mPerDelta) - (mCutoff - mPerDelta));
    
    if (mountainExpNoiseOffset < 0)
    {
        mountainExpNoiseOffset = 0;
    }
    if (mountainExpNoiseOffset > 1)
    {
        mountainExpNoiseOffset = 1;
    }
    
    if (mountainExpNoiseOffset < 0.5f)
    {
        mountainPersistence = (1 - sqrt(1 - pow(2 * mountainExpNoiseOffset, 2))) / 2;

    }
    else
    {
        mountainPersistence = (sqrt(1 - pow(-2 * mountainExpNoiseOffset + 2, 2)) + 1) / 2;
    }
    //mountainPersistence = pow(2, 10 * mountainExpNoiseOffset - 10);
    clamp(mountainPersistence, 0, 1);
    
    if (mountainPersistence < 0)
    {
        mountainPersistence = 0;
    }
    if (mountainPersistence > 1)
    {
        mountainPersistence = 1;
    }

    //mountainPersistence = 1;
    //varMountainExp = 1;
    topheight += ((pow((noise * 10), varMountainExp)) * (((varMountainHeight) / 100) / (pow(10, (varMountainExp - 2)))) * mountainPersistence);
        
    topheight -= hillNoise * 25;
    
    float caveDelta = 10;
    //the area that smoothens the moutain, higher just means higher mountains, so should as low as possible, thus not adjustable
    float mountainSmoothness = 5;
    
    
    //==============================================================================================================================
    //====================================                                       CAVES                                                     ==============================
    //==============================================================================================================================
    
    
    for (int m = 1; m < 5; m++)
    {
        float factor = pow(2, m);
        caveResult -= selfmadeperlin(caveX * factor, caveY * factor, caveZ * factor) / factor;
    }
    
    
    //==================================                   Bigger cave generation                ==========================================================
    


    float newCaveCutoff = caveCutoff;
    
    if (currentHeight > caveMin)
    {
        float absMin = caveMin - caveMin;
        float absMax = caveMax - caveMin;
        float deltaMin = absMin + caveDelta;
        float deltaMax = absMax - caveDelta;
    
        float test = (currentHeight - caveMin) / absMax;
        if (test <= 1)
        {
            test *= 2;
            test -= 1;
            test = abs(test) - 1;
            test = abs(test) * 2;
            newCaveCutoff += test * caveStrength;
            clamp(newCaveCutoff, 0, 1);
        }
    }
    
    //==================================                   Lerping                ==========================================================
    
    if (caveResult > newCaveCutoff)
    {
        caveResult = 0;
    }
    else
    {
        caveResult = 1 - (caveResult / newCaveCutoff);
    }
        
    float endResult = caveResult;
    
    if (currentHeight > topheight - caveDelta)
    {
        //    /x means the amount of caves that go to surface, the higher the number, the more entrances
        endResult -= (1 - ((topheight - currentHeight) / caveDelta)) / 4;
    }
    

    //==============================================================================================================================
    //==================================                                       TERRAIN                                                     ==============================
    //==============================================================================================================================
    


    if (currentHeight > topheight)
    {
        endResult += (1 - (topheight + mountainSmoothness - currentHeight) / mountainSmoothness);
        //extra layer of bumpiness
        float value = selfmadeperlin(baseX / 5.5f, baseY / 10.5f, baseZ / 5.5f);
        float value2 = selfmadeperlin(baseX / 9.5f, baseY / 37.5f, baseZ / 9.5f);
        //combine it to the endresult, value/2 so that value2 has more impact, both /x, where x is the persistence
        endResult -= (value / 2 + value2) / 2;
    }


    float treeNoise = heightmapNoise(baseX / 200.5f, baseZ / 200.5f);
    float subTreeNoise = heightmapNoise(baseX / 20.5f, baseZ / 20.5f);
    
    
    if (currentHeight < groundHeight + mountainHeight - 100)
    {
        if (currentHeight > topheight && currentHeight < topheight + 1)
        {
            if (treeNoise > 0.55f)
            {
                if (subTreeNoise > 0.35f)
                {
                    treePositions.Append(float3(baseX, currentHeight + 3, baseZ));
                }
            }
        }
    }
    
    float flowerNoise = heightmapNoise(baseX / 20.f, baseZ / 20.5f);
    
    if (currentHeight < groundHeight + mountainHeight - 200)
    {
        if (flowerNoise > 0.5f)
        {
            flowerPositions.Append(float3(baseX, currentHeight + 3, baseZ));
        }
    }
    
    return endResult;
}





[numthreads(numThreads, numThreads, numThreads)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    //if id is outside boundary return, this can happen due to that pointsperaxis/numthreads is not an int
    if (id.x >= pointsPerAxis || id.y >= pointsPerAxis  || id.z >= pointsPerAxis )
    {
        return;
    }

    varGroundHeight = groundHeight;
    varMountainExp = exp;
    varMountainFrequention = heightMapScale;
    varMountainHeight = mountainHeight;
    
    
    
    //generate a value based on position and add it to the buffer, together with the postion
    float3 newPos = startingValue;

    

    newPos.x = (startingValue.x + (id.x * size ));
    newPos.y = (startingValue.y + (id.y * size ));
    newPos.z = (startingValue.z + (id.z * size ));

    float result = worms(newPos.x, newPos.y, newPos.z);
    
    vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size , id.y * size , id.z * size , result));
   
}


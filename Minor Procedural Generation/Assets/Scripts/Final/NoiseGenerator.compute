// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "/Lib/NoiseLib.compute"

const float1 chunkSize;
const float1 row;
const float1 height;
const float1 column;
const float1 size;
const float1 noiseScale;
const float1 repeat;
const int pointsPerAxis;
const float1 groundHeight;
const float1 mountainHeight;
const float1 persistence;
const float1 lacunarity;
const int octaves = 1;


float3 startingValue;


RWStructuredBuffer<float4> vertexPerlin;

static int numThreads = 8;



float interpolate(float value)
{
    return value * value * value * (value * (value * 6 - 15) + 10);
}


static float gradplane(int hash, float x, float y)
{
    switch (hash & 0x3)
    {
        case 0x0:
            return x + y;
        case 0x1:
            return -x + y;
        case 0x2:
            return x - y;
        case 0x3:
            return -x - y;
        default:
            return 0; // never happens
    }
}

float heightmapNoise(float x, float y)
{
    //points in the perlin space
    float pointA = x - floor(x);
    float pointB = y - floor(y);

    // Calculate the "unit cube" that the point asked will be located in
    int xi = (int) x & 255;
    int yi = (int) y & 255;
    
    //get a semi-random number from a table for 255 included numbers
    int testA = p[p[xi] + yi];
    int testB = p[p[xi + 1] + yi];
    int testC = p[p[xi] + yi + 1];
    int testD = p[p[xi + 1] + yi + 1];
    
    //based on those random numbers generate a direction, in this case from 4 different directions
    float testAh = gradplane(testA, pointA, pointB);
    float testBh = gradplane(testB, pointA - 1, pointB);
    float testCh = gradplane(testC, pointA, pointB - 1);
    float testDh = gradplane(testD, pointA - 1, pointB - 1);
    
    
    //Combine the directions together, 2 at the time, first on the X axis
    double resultA = lerp(testAh, testBh, interpolate(pointA));
    double resultB = lerp(testCh, testDh, interpolate(pointA));

    //then combine those 2 values together on the y axis
    float endResult = (float) lerp(resultA, resultB, interpolate(pointB));
    endResult = (endResult + 1) / 2;
    return endResult;
}


float selfmadeperlin(float x, float y, float z)
{

 

    int xi = (int) x & 255; // Calculate the "unit cube" that the point asked will be located in
    int yi = (int) y & 255; // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that
    int zi = (int) z & 255; // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.
    
    float pointX = x - floor(x);
    float pointY = y - floor(y);
    float pointZ = z - floor(z);

    
    
    float interX = interpolate(pointX);
    float interY = interpolate(pointY);
    float interZ = interpolate(pointZ);

    int cornerA = p[p[p[xi] + yi] + zi];
    int cornerB = p[p[p[xi] + yi + 1] + zi];
    int cornerC = p[p[p[xi] + yi] + zi + 1];
    int cornerD = p[p[p[xi] + yi + 1] + zi + 1];
    
    int cornerE = p[p[p[xi + 1] + yi] + zi];
    int cornerF = p[p[p[xi + 1] + yi + 1] + zi];
    int cornerG = p[p[p[xi + 1] + yi] + zi + 1];
    int cornerH = p[p[p[xi + 1] + yi + 1] + zi + 1];

    float cornerAdir = grad(cornerA, pointX, pointY, pointZ);
    float cornerBdir = grad(cornerB, pointX, pointY - 1, pointZ);
    float cornerCdir = grad(cornerC, pointX, pointY, pointZ - 1);
    float cornerDdir = grad(cornerD, pointX, pointY - 1, pointZ - 1);
    
    float cornerEdir = grad(cornerE, pointX - 1, pointY, pointZ);
    float cornerFdir = grad(cornerF, pointX - 1, pointY - 1, pointZ);
    float cornerGdir = grad(cornerG, pointX - 1, pointY, pointZ - 1);
    float cornerHdir = grad(cornerH, pointX - 1, pointY - 1, pointZ - 1);
    
    float resultA = lerp(cornerAdir, cornerEdir, interX);
    float resultB = lerp(cornerBdir, cornerFdir, interX);
    float resultC = lerp(cornerCdir, cornerGdir, interX);
    float resultD = lerp(cornerDdir, cornerHdir, interX);
    
    float resultE = lerp(resultA, resultB, interY);
    float resultF = lerp(resultC, resultD, interY);
    
    float resultG = lerp(resultE, resultF, interZ);
    
    
    
    float result = (((resultG + 1) / 2) - 0.25f) * 2;
    return result;

    //return y1;
}


int getIndex(int x, int y, int z)
{
    //since xyz is going from 0 to number, it can will return correct number
    //example: if points per axis is 10, it means that xyz max is 9. So the final number will be 999
    //this is correct because 10x10x10 is 1000, and 0 - 999 is 1000.
    int index = z * pointsPerAxis * pointsPerAxis + y * pointsPerAxis + x;

    return index;
}



float length = 350;



float worms(float x, float y, float z)
{
    float currentHeight = y;
    
    x /= noiseScale;
    y /= noiseScale;
    z /= noiseScale;
    
    float result = selfmadeperlin(x, y, z);
    
    float low = 0.45f;
    float high = 0.65f;
    float weight2 = 0.5f;
  
    
    if (result < high && result > low)
    {
        float value = result - low;
        value = value * (1 / (high - low));
        value *= 2;
        value -= 1;
        if (value < 0)
        {
            value *= -1;
        }
        result = 1;
    }
    else
    {
        result = 0;
    }
    return result;
        
    //result = 0;
    
    //height noise map
    float noise = 0;
    float weight = 1;
    float testScale = noiseScale;
        
    for (int j = 0; j < octaves; j++)
    {
        float test2 = heightmapNoise(x / testScale, z / testScale);
        noise += (test2 * weight);
        testScale *= lacunarity;
        weight *= persistence;
    }
        
    
    
    //makes sure closer to the surface there is more ground
    float maxHeight = mountainHeight + groundHeight;
    if (currentHeight > groundHeight)
    {
        //y
        float cave = (currentHeight - groundHeight) / 50 * noise;
        result -= cave;
        
        float max = groundHeight + (maxHeight - groundHeight) * (noise);
        if (currentHeight > max - 50)
        {
            float delta2 = max - currentHeight;
            result -= delta2 / 10;
        }
    }
    if (result > 1)
    {
        result = 1;
    }
    vertexPerlin[getIndex(x, y, z)] = (float4(x * size, y * size, z * size, result));
    return result;
    
    
    //something funny
    float test = 0;
    float floatweight = currentHeight / 350;
    if (floatweight >= 0)
    {
        result += test * floatweight;
    }
    if (result > 1)
    {
        result = 1;
    }
    return result;
}





[numthreads(numThreads, numThreads, numThreads)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= pointsPerAxis || id.y >= pointsPerAxis || id.z >= pointsPerAxis)
    {
        return;
    }
    //generate a value based on position and add it to the buffer, together with the postion
    float3 newPos = startingValue;
    
    newPos.x = (startingValue.x + (id.x * size));
    newPos.y = (startingValue.y + (id.y * size));
    newPos.z = (startingValue.z + (id.z * size));
    

    //worms(id.x, id.y, id.z);
    vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size, id.y * size, id.z * size, worms(newPos.x, newPos.y, newPos.z)));
    
    
    //vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size, id.y * size, id.z * size, 0.5f));
    

        

}


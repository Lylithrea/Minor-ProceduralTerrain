// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "/Lib/NoiseLib.compute"

const float1 chunkSize;
const float1 row;
const float1 height;
const float1 column;
const float1 size;
const float1 noiseScale;
const float1 repeat;
const int pointsPerAxis;
const float1 groundHeight;
const float1 mountainHeight;
const float1 persistence;
const float1 lacunarity;
const int octaves = 1;


float3 startingValue;


RWStructuredBuffer<float4> vertexPerlin;

static int numThreads = 8;



float interpolate(float value)
{
    return value * value * value * (value * (value * 6 - 15) + 10);
}


static float gradplane(int hash, float x, float y)
{
    switch (hash & 0x3)
    {
        case 0x0:
            return x + y;
        case 0x1:
            return -x + y;
        case 0x2:
            return x - y;
        case 0x3:
            return -x - y;
        default:
            return 0; // never happens
    }
}

float heightmapNoise(float x, float y)
{
    //points in the perlin space
    float pointA = x - floor(x);
    float pointB = y - floor(y);

    // Calculate the "unit cube" that the point asked will be located in
    int xi = (int) x & 255;
    int yi = (int) y & 255;
    
    //get a semi-random number from a table for 255 included numbers
    int testA = p[p[xi] + yi];
    int testB = p[p[xi + 1] + yi];
    int testC = p[p[xi] + yi + 1];
    int testD = p[p[xi + 1] + yi + 1];
    
    //based on those random numbers generate a direction, in this case from 4 different directions
    float testAh = gradplane(testA, pointA, pointB);
    float testBh = gradplane(testB, pointA - 1, pointB);
    float testCh = gradplane(testC, pointA, pointB - 1);
    float testDh = gradplane(testD, pointA - 1, pointB - 1);
    
    
    //Combine the directions together, 2 at the time, first on the X axis
    double resultA = lerp(testAh, testBh, interpolate(pointA));
    double resultB = lerp(testCh, testDh, interpolate(pointA));

    //then combine those 2 values together on the y axis
    float endResult = (float) lerp(resultA, resultB, interpolate(pointB));
    endResult = (endResult + 1) / 2;
    return endResult;
}


float selfmadeperlin(float x, float y, float z)
{

 

    int xi = (int) x & 255; // Calculate the "unit cube" that the point asked will be located in
    int yi = (int) y & 255; // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that
    int zi = (int) z & 255; // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.
    
    float pointX = x - floor(x);
    float pointY = y - floor(y);
    float pointZ = z - floor(z);

    
    
    float interX = interpolate(pointX);
    float interY = interpolate(pointY);
    float interZ = interpolate(pointZ);

    int cornerA = p[p[p[xi] + yi] + zi];
    int cornerB = p[p[p[xi] + yi + 1] + zi];
    int cornerC = p[p[p[xi] + yi] + zi + 1];
    int cornerD = p[p[p[xi] + yi + 1] + zi + 1];
    
    int cornerE = p[p[p[xi + 1] + yi] + zi];
    int cornerF = p[p[p[xi + 1] + yi + 1] + zi];
    int cornerG = p[p[p[xi + 1] + yi] + zi + 1];
    int cornerH = p[p[p[xi + 1] + yi + 1] + zi + 1];

    float cornerAdir = grad(cornerA, pointX, pointY, pointZ);
    float cornerBdir = grad(cornerB, pointX, pointY - 1, pointZ);
    float cornerCdir = grad(cornerC, pointX, pointY, pointZ - 1);
    float cornerDdir = grad(cornerD, pointX, pointY - 1, pointZ - 1);
    
    float cornerEdir = grad(cornerE, pointX - 1, pointY, pointZ);
    float cornerFdir = grad(cornerF, pointX - 1, pointY - 1, pointZ);
    float cornerGdir = grad(cornerG, pointX - 1, pointY, pointZ - 1);
    float cornerHdir = grad(cornerH, pointX - 1, pointY - 1, pointZ - 1);
    
    float resultA = lerp(cornerAdir, cornerEdir, interX);
    float resultB = lerp(cornerBdir, cornerFdir, interX);
    float resultC = lerp(cornerCdir, cornerGdir, interX);
    float resultD = lerp(cornerDdir, cornerHdir, interX);
    
    float resultE = lerp(resultA, resultB, interY);
    float resultF = lerp(resultC, resultD, interY);
    
    float resultG = lerp(resultE, resultF, interZ);
    
    
    //most values are between 0.25f and 0.75, this formula tries to normalize it to 0 to 1
    float result = (((resultG + 1) / 2) - 0.25f) * 2;
    return result;

    //return y1;
}


int getIndex(int x, int y, int z)
{
    //since xyz is going from 0 to number, it can will return correct number
    //example: if points per axis is 10, it means that xyz max is 9. So the final number will be 999
    //this is correct because 10x10x10 is 1000, and 0 - 999 is 1000.
    int index = z * pointsPerAxis * pointsPerAxis + y * pointsPerAxis + x;

    return index;
}



float length = 350;



float worms(float x, float y, float z)
{
    float currentHeight = y;
    
    float baseX = x;
    float baseY = y;
    float baseZ = z;
    
    
    float caveX = x / 150;
    float caveY = y / 150;
    float caveZ = z / 150;
    

    x /= noiseScale;
    y /= noiseScale;
    z /= noiseScale;
    
    //float result = selfmadeperlin(x, y, z);
    
    float result = 1;
    float caveResult = 1;
    
    float weight2 = 0;
  
    float agressiveness = 15.5f;
    

    
    for (int n = 1; n < 5; n++)
    {
        float factor = pow(2, n);
        result -= selfmadeperlin(x * factor, y * factor, z * factor) / factor;
    }
    
    
    for (int m = 1; m < 5; m++)
    {
        float factor = pow(2, m);
        caveResult -= selfmadeperlin(caveX * factor, caveY * factor, caveZ * factor) / factor;
    }
    
    float caveheight = 0.65f;
    if (caveResult > caveheight)
    {
        caveResult = 0;
    }
    else
    {
        caveResult = 1 - (caveResult / caveheight);
    }
    
    
    
    //cave worms
    float low = 0.45f;
    float high = 0.65f;

    
    float newHigh = high;
    float newLow = low;

    float scalar = selfmadeperlin(x / 25.5f, y / 25.5f, z / 25.5f);
    
    scalar *= agressiveness;
    scalar -= agressiveness / 2;


    if (weight2 != 0)
    {
        newHigh += scalar * weight2;
        newLow -= scalar * weight2;
    }
    
    if (result < newHigh && result > newLow)
    {
        float value = result - low;
        value = value * (1 / (newHigh - newLow));
        value *= 2;
        value -= 1;
        if (value < 0)
        {
            value *= -1;
        }
        result = 1 - value;
    }
    else
    {
        result = 0;
    }

    
    //meh
    //return caveResult + result;
    
    //meh
    //return result;
    
    //for pretty good not interconnected cave systems
    //return caveResult;
    
    
    
   //result += selfmadeperlin(x / 350, y / 350, z / 350) / 2;
    //result += selfmadeperlin(x / agressiveness, y / agressiveness, z / agressiveness) * weight2;

        
    //result = 0;
    
    //height noise map
    float noise = 0;
    float weight = 1;
    float testScale = 150;
        
    float maxValue = 0;
    
    for (int j = 0; j < octaves; j++)
    {
        float test2 = heightmapNoise(baseX / testScale , baseZ / testScale );
        noise += (test2 * weight);
        maxValue += (0.9f * weight);
        testScale *= lacunarity;
        weight *= persistence;
    }
        
    //noise = (noise / ( octaves * persistence));
    //noise = noise / maxValue;
    //noise = noise * (maxValue - noise);
    noise = noise / maxValue;
    
    float endResult = caveResult;
    //endResult += (currentHeight - 350 - noise) / 100;
    
    float gh = 350;
 
    float mh = 500;
    float ch = 300;
    
    //gh -= octaves * 20;
    //1 = air!! -------------------------------------------------------

    
    float topheight = gh;
    //endResult = 0;

    
    
    //topheight += noise * mh;
    
    float exp = 4;
    
    topheight += (pow((noise * 10), exp)) * (((mh) / 100) / (pow(10, (exp - 2))));
    
    
    float caveheight2 = ch + noise * mh;
    float caveDelta = 10;

    endResult = caveResult;
    //clamp(endResult, 0, 1);
    
    if (currentHeight > topheight - caveDelta)
    {
    //caves
        //endResult = 0;
        
        //3 means the amount of caves that go to surface, the higher the number, the more entrances
        endResult -= (1 - ((topheight - currentHeight) / caveDelta)) / 4;
        
        if (caveheight2 > gh)
        {
            //endResult -= (1 - (caveheight2 - currentHeight) / (caveheight2 - ch) * noise);
        }
        else
        {
            //endResult -= (1 - (gh - currentHeight) / (gh - ch) * noise);
        }
        
    }
    float mountainSmoothness = 5;

    if (currentHeight > topheight)
    {
        endResult += (1 - (topheight + mountainSmoothness - currentHeight) / mountainSmoothness);
        float value = selfmadeperlin(baseX / 5.5f, baseY / 10.5f, baseZ / 5.5f);
        float value2 = selfmadeperlin(baseX / 9.5f, baseY / 37.5f, baseZ / 9.5f);
        endResult -= (value / 2 + value2) / 3;
    }
    clamp(endResult, 0, 1);

    return endResult;
    
    
    
    /*
    float topheight = gh;
    //endResult = 0;

    topheight += noise * mh;
    float caveheight2 = ch + noise * mh;
    float caveDelta = 10;

    endResult = caveResult;
    
    if (currentHeight > topheight - caveDelta)
    {
    //caves
        //endResult = 0;
        
        
        endResult += 1 - (topheight - currentHeight) / caveDelta;
        
        if (caveheight2 > gh)
        {
            //endResult -= (1 - (caveheight2 - currentHeight) / (caveheight2 - ch) * noise);
        }
        else
        {
            //endResult -= (1 - (gh - currentHeight) / (gh - ch) * noise);
        }
        
    }
    //clamp(endResult, 0, 1);
    //endResult = 0;

    if (currentHeight > topheight)
    {
        //mountains
        //endResult += ( (currentHeight - topheight) / (topheight - gh));
        //endResult -= caveResult * (1 - endResult);
        endResult = 1;
    }
    
    */
    
    
    
    
    //makes sure closer to the surface there is more ground
    float maxHeight = mountainHeight + groundHeight;
    if (currentHeight > groundHeight)
    {
        //y
        float cave = (currentHeight - groundHeight) / 100 * noise;
        endResult -= cave;
        
        float max = groundHeight + (maxHeight - groundHeight) * (noise);
        if (currentHeight > max - 50)
        {
            float delta2 = max - currentHeight;
            //endResult -= delta2 / 10;
        }
    }
    if (endResult > 1)
    {
        endResult = 1;
    }
    
    return endResult;
    //vertexPerlin[getIndex(x, y, z)] = (float4(x * size, y * size, z * size, result));
    return result;
    
    
    //something funny
    float test = 0;
    float floatweight = currentHeight / 350;
    if (floatweight >= 0)
    {
        result += test * floatweight;
    }
    if (result > 1)
    {
        result = 1;
    }
    return result;
}





[numthreads(numThreads, numThreads, numThreads)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    
        
    float1 skip = 1;
    
    if (id.x >= pointsPerAxis / skip || id.y >= pointsPerAxis / skip || id.z >= pointsPerAxis / skip)
    {
        return;
    }
    //row of smaller squares
    if (id.x >= pointsPerAxis / skip - 2 || id.y >= pointsPerAxis / skip - 2 || id.z >= pointsPerAxis / skip - 2)
    {
        float3 newPos = startingValue;

        newPos.x = (startingValue.x + (id.x * size ));
        newPos.y = (startingValue.y + (id.y * size ));
        newPos.z = (startingValue.z + (id.z * size ));
    

    //worms(id.x, id.y, id.z);
        vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size , id.y * size , id.z * size , worms(newPos.x, newPos.y, newPos.z)));
    }
    if (id.x < 2 || id.y < 2 || id.z < 2)
    {
        float3 newPos = startingValue;

        newPos.x = (startingValue.x + (id.x * size));
        newPos.y = (startingValue.y + (id.y * size));
        newPos.z = (startingValue.z + (id.z * size));
    

    //worms(id.x, id.y, id.z);
        vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size, id.y * size, id.z * size, worms(newPos.x, newPos.y, newPos.z)));
    }
    else
    {

    //generate a value based on position and add it to the buffer, together with the postion
        float3 newPos = startingValue;

    

        newPos.x = (startingValue.x + (id.x * size * skip));
        newPos.y = (startingValue.y + (id.y * size * skip));
        newPos.z = (startingValue.z + (id.z * size * skip));
    

    //worms(id.x, id.y, id.z);
        vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size * skip, id.y * size * skip, id.z * size * skip, worms(newPos.x, newPos.y, newPos.z)));
   
    
    
    //vertexPerlin[getIndex(id.x, id.y, id.z)] = (float4(id.x * size, id.y * size, id.z * size, 0.5f));
    }

        

}

